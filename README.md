## TypeScript Fullstack Boilerplate (WIP)

![](https://img.shields.io/github/stars/pedroknup/ts-boilerplate?style=flat) ![](https://img.shields.io/github/forks/pedroknup/ts-boilerplate?style=flat) ![](https://img.shields.io/github/watchers/pedroknup/ts-boilerplate?style=flat)

Note: This boilerplate is still under construction. Some functionalities might be not finished or polished.

A complete NodeJS + TypeScript boilerplate made with React + Redux + Swagger Model generator + SCSS + Material UI (client) and ExpressJS + TypeORM + Swagger Documentation generator + JWT authentication and role based authorization. It's configured to work as containers as well (docker-compose). I've configured Swagger to automatically create a documentation for the API and, with that, automatically generate API classes on the client side. In that way, to make API calls on the client, we just need to call the API generated class' methods! Very cool, right?


## Web Service

This RESTful Web Service makes use of TypeORM to automatically generate models based on our database. In that way, we can deal with our stored data as objects, ideal for a typed environment (TypeScript). All (or almost all) endpoints are previously validated and authenticated via a middleware. So if the request doesn't have a valid token (JWT), it will return a 401/403 code right away. If the token is valid, the controller will receive the authenticated user and, at that point, it's guaranteed the user is properly authenticated.

*What is a JWT and why we use it to make stateless authentications*
[*5 Easy Steps to Understanding JSON Web Tokens (JWT)*
*In this article, the fundamentals of what JSON Web Tokens (JWT) are, and why they are used will be explained. JWT are…*medium.com](https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec)

*What is an ORM (Object-Relational-Mapper)*
[*What is an ORM and Why You Should Use it*
*An introduction to Object-Relational-Mappers*blog.bitsrc.io](https://blog.bitsrc.io/what-is-an-orm-and-why-you-should-use-it-b2b6f75f5e2a)

## Why TypeORM?

TypeORM allows you to write only one TypeScript Class and, with the synchronize tool, it automatically generates all SQL structure for your entity. With the class-validator package we can use the same model class to make validations.

It is compatible with MySQL / MariaDB / Postgres / SQLite / Microsoft SQL Server / Oracle / sql.js / MongoDB. You can switch between those databases without having to rewrite your code.

We are going to start this project with SQLite. I don’t recommend keeping it for production. But, because I don’t know what DB you are going to use, it allows us to make a generic project that you can run with just “npm install”, without having to setup a database server.

## Application

This boilerplate has implemented a to-do app. Every user has his own to-dos.

#### Interesting features: 
- Dynamic expandable sidebar with a toggle state (state managed by Redux):
<img align="left" src="https://i.giphy.com/kyowCvm0oWAvDk3Fbj.gif">

- Responsiveness:
<img align="left" src="https://i.giphy.com/f9lFppmIGCnbv0QHJ3.gif">


- Individual to-do asynchronous API calls:
	 - Internet connection slowed down to a low-tier speed (to better see the to-do's individuality):
      <img align="left" src="https://i.giphy.com/kyid9gcBQFpVzypjMa.gif">
	 - Normal speed:
      <img align="left" src="https://i.giphy.com/kH0ogTmdnUYIDwiPeT.gif">

This stack is currently my favorite to work with and I think with that use case (to-do) it's easier to start a project with those technologies already configured and ready for use. This project it might be also interesting for those who wants to learn/better understand how those technologies works.

### Commands:

On client: `npm run generate-api` to automatically generate API classes for API calls based on Web Service's documentation generated by Swagger (ap-url/api-docs.json).
On web service: `npm run generate-models` to automatically generate TypeORM classes for the database entities.
On client/web service: `npm start` to start the service.


### To-do:

- [ ] Sign In and forget password features. 
- [ ] Client: refactor the code putting all the API calls on its respective middleware thunks, and not in redux middleware.
- [ ] Client: remove inline styles creating proper style classes on a scss file.
- [ ] API: refactor the code making it run time exception proof (try-catch).
- [ ] Create environment variables to explicitly set the database's auth data, services ports etc. For now everything is statically declared. Not epic.
- [ ] Client: refactor the reducer's implementation.
- [ ] Unit tests implementation.


Pull requests are very welcome! If you have any suggestions, please get in touch or create a PR. Feel free to fork this repository as well :)



